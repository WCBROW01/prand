# prand

Actual name coming at some point.

C implementation of a pseudorandom number generation algorithm written by [EnderPi](https://github.com/EnderPi). This is an algorithm generated by his [FlemishGiant](https://github.com/EnderPi/FlemishGiant) project, and a C# implementation of this exact algorithm is included within it as well. It is not a very conventional algorithm, and is quite unusual. It has gone through quite extensive testing to ensure its effectiveness, and is suitable even for cryptography.

The random number generator is based on a balanced Feistel network, and state is stored as an array of keys. The generator was tested to be safe with 18 passes through the round function, and this number was increased to 24 for extra safety.

## Usage

Include the source/header pair in your project just as you would your own source code!

### Using the global generator
Use `prand_seed()` to provide a seed to the generator. If none is provided, 1 will be used as a default seed.
Use `prand()` to obtain a 64-bit unsigned integer from the generator.
The `prand_getstate()` and `prand_setstate()` functions will let you obtain the state of the global random number generator for your own use and replace the global state with your own state.

### Using the reentrant functions
Allocate your own `prand_t` anywhere you want on the stack, heap, or in static memory.
If you aren't pulling the global state, seed the newly allocated generator using `prand_seed_r()` before using it! Failure to do this is undefined behavior.
Use `prand_r()` to generate a random number using your own generator.

## Changes from Ender's implementation:

- The internal LCG takes a pointer to your seed as a parameter, rather than relying on global state.
- There are two different ways to use it: You can either use it with a global state, (which is thread-local if you have a C11 compiler!) or store your own instance of the generator state somewhere on the stack or heap.
